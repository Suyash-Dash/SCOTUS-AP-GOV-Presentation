<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D U.S. Supreme Court</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
    <script>
        let scene, camera, renderer, controls;
        let person, doors;
        let doorOpened = false;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Blue sky background

            // Clouds
            createClouds();
            createClouds2();



            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 20);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Supreme Court Model
            createSupremeCourt();

            // Animated Person
            createPerson();

            // Render Loop
            animate();
        }

        function createClouds() {
            // Create clouds in the background
            const cloudGeometry = new THREE.SphereGeometry(5, 32, 32);
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud.position.set(50, 20, -50);
            cloud.scale.set(3, 1, 3);
            scene.add(cloud);
        }

        function createClouds2() {
            // Create clouds in the background
            const cloudGeometry = new THREE.SphereGeometry(5, 32, 32);
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
            const cloud2 = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud2.position.set(-50, 40, -50);
            cloud2.scale.set(3, 1, 3);
            scene.add(cloud2);
        }

        function createSupremeCourt() {
            const courtGroup = new THREE.Group();

            // Base
            const baseGeometry = new THREE.BoxGeometry(15, 1, 10);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xdcdcdc });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(0, -0.5, 0.5);
            scene.add(base);

            // Main Build
            const buildGeometry = new THREE.BoxGeometry(15, 15, 4);
            const buildMaterial = new THREE.MeshStandardMaterial({ color: 0xdcdcdc });
            const build = new THREE.Mesh(buildGeometry, buildMaterial);
            build.position.set(0, 2, -1.5);
            scene.add(build);

            // Main Long
            const longGeometry = new THREE.BoxGeometry(50, 12, 20);
            const longMaterial = new THREE.MeshStandardMaterial({ color: 0xdcdcdc });
            const long = new THREE.Mesh(longGeometry, longMaterial);
            long.position.set(0, 2, -10.5);
            scene.add(long);





            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1e90ff, // Bright blue window color
                transparent: true, 
                opacity: 0.7,  // Glass-like transparency
                roughness: 0.1, // Slight reflection
                metalness: 0.8  // Glass shine effect
            });
            
            const windowWidth = 1;   // Width of each window
            const windowHeight = 2;  // Height of each window
            const windowDepth = 0.1; // Very thin depth to simulate glass
            const windowSpacing = 3; // Space between each window
            const numWindows = 5;    // Number of windows per row
            
            for (let i = 0; i < numWindows; i++) {
                const windowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
            
                // Adjust window position along the front wall
                const xPosition = -7 + i * windowSpacing; // Moves windows left to right
                windowMesh.position.set(xPosition-14, 3, -0.25); // Adjust Y for height, Z for depth
            
                scene.add(windowMesh);
            }


            const windowMaterial2 = new THREE.MeshStandardMaterial({ 
                color: 0x1e90ff, // Bright blue window color
                transparent: true, 
                opacity: 0.7,  // Glass-like transparency
                roughness: 0.1, // Slight reflection
                metalness: 0.8  // Glass shine effect
            });
            
            const windowWidth2 = 1;   // Width of each window
            const windowHeight2 = 2;  // Height of each window
            const windowDepth2 = 0.1; // Very thin depth to simulate glass
            const windowSpacing2 = 3; // Space between each window
            const numWindows2 = 5;    // Number of windows per row
            
            for (let i = 0; i < numWindows2; i++) {
                const windowGeometry2 = new THREE.BoxGeometry(windowWidth2, windowHeight2, windowDepth2);
                const windowMesh = new THREE.Mesh(windowGeometry2, windowMaterial2);
            
                // Adjust window position along the front wall
                const xPosition = -7 + i * windowSpacing; // Moves windows left to right
                windowMesh.position.set(xPosition+16, 3, -0.25); // Adjust Y for height, Z for depth
            
                scene.add(windowMesh);
            }


            const windowMaterial3 = new THREE.MeshStandardMaterial({ 
                color: 0x1e90ff, // Bright blue window color
                transparent: true, 
                opacity: 0.7,  // Glass-like transparency
                roughness: 0.1, // Slight reflection
                metalness: 0.8  // Glass shine effect
            });
            
            const windowWidth3 = 2.5;   // Width of each window
            const windowHeight3 = 3;  // Height of each window
            const windowDepth3 = 0.1; // Very thin depth to simulate glass
            const windowSpacing3 = 3; // Space between each window
            const numWindows3 = 1;    // Number of windows per row
            
            for (let i = 0; i < numWindows3; i++) {
                const windowGeometry3 = new THREE.BoxGeometry(windowWidth3, windowHeight3, windowDepth3);
                const windowMesh = new THREE.Mesh(windowGeometry3, windowMaterial3);
            
                // Adjust window position along the front wall
                const xPosition = -7 + i * windowSpacing; // Moves windows left to right
                windowMesh.position.set(xPosition+7, 4, 0.5); // Adjust Y for height, Z for depth
            
                scene.add(windowMesh);
            }



            const blackMaterial3 = new THREE.MeshStandardMaterial({ 
                color: 0x000000, // Bright blue window color


                
            });
            
            const blackWidth3 = 2.0;   // Width of each window
            const blackHeight3 = 2.5;  // Height of each window
            const blackDepth3 = 0.1; // Very thin depth to simulate glass
            const blackSpacing3 = 3; // Space between each window
            const numblack3 = 1;    // Number of windows per row
            
            for (let i = 0; i < numblack3; i++) {
                const blackGeometry3 = new THREE.BoxGeometry(blackWidth3, blackHeight3, blackDepth3);
                const windowMesh = new THREE.Mesh(blackGeometry3, blackMaterial3);
            
                // Adjust window position along the front wall
                const xPosition = -7 + i * blackSpacing3; // Moves windows left to right
                windowMesh.position.set(xPosition+7, 1, 0.5); // Adjust Y for height, Z for depth


                windowMesh.visible = true; // ðŸ”¹ Hide windows initially
                scene.add(windowMesh);

            }
            


// Roof (Triangular Prism with a Square Base)
const topGeometry = new THREE.BufferGeometry();

// Define the vertices (positions of each corner)
// This makes a prism with a square base and a triangular top
const vertices = new Float32Array([
    // Base square (bottom face)
    -7.5, 0, -2,   // 0 - Bottom-left
     7.5, 0, -2,   // 1 - Bottom-right
     7.5, 0,  2,   // 2 - Top-right
    -7.5, 0,  2,   // 3 - Top-left

    // Top Triangle (Front and Back Peaks)
     0, 8, -2,   // 4 - Peak of front triangle
     0, 8,  2    // 5 - Peak of back triangle
]);

// Define the faces (indexing vertices to create triangles)
const indices = [
    // Bottom face (square)
    0, 1, 2,
    0, 2, 3,

    // Front triangular face
    0, 1, 4,

    // Back triangular face
    3, 2, 5,

    // Left slanted face
    0, 3, 5,
    0, 5, 4,

    // Right slanted face
    1, 2, 5,
    1, 5, 4
];

topGeometry.setIndex(indices);
topGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
topGeometry.computeVertexNormals(); // To ensure proper lighting

const topMaterial = new THREE.MeshStandardMaterial({ color: 0xd3d3d3 }); // Light gray roof
const top = new THREE.Mesh(topGeometry, topMaterial);
top.position.set(0, 9, 3.4); // Adjusted position to sit correctly on the building
scene.add(top);
















            // Ground
            const groundGeometry = new THREE.BoxGeometry(100, 1, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x808080   });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.set(0, -1.5, 0.5);
            scene.add(ground);

            // Columns - Add more for realism
            for (let i = -7; i <= 7; i += 14) {
                const columnGeometry = new THREE.CylinderGeometry(0.3, 0.3, 14, 32);
                const columnMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const column = new THREE.Mesh(columnGeometry, columnMaterial);
                column.position.set(i, 2, 3);
                courtGroup.add(column);
            }

            // Columns Back - Add more for realism
            for (let i = -7; i <= 7; i += 2) {
                const columnGeometry = new THREE.CylinderGeometry(0.3, 0.3, 14, 32);
                const columnMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const column = new THREE.Mesh(columnGeometry, columnMaterial);
                column.position.set(i, 2, 5);
                courtGroup.add(column);
            }

            // Roof - Add more layers or details here if desired
            const roofGeometry = new THREE.BoxGeometry(15, 1, 5);
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 9, 3);
            courtGroup.add(roof);

            // Doors - Modify for more detailed doors or add additional sets
            const doorGeometry = new THREE.BoxGeometry(1, 2.5, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x663300 });
            doors = [
                new THREE.Mesh(doorGeometry, doorMaterial),
                new THREE.Mesh(doorGeometry, doorMaterial)
            ];
            doors[0].position.set(-0.5, 1, 0.5);
            doors[1].position.set(0.5, 1, 0.5);
            courtGroup.add(doors[0], doors[1]);

            // Optional: Add more architectural features here like windows, side buildings, etc.
            // Example: create a window or side wall by creating a new geometry and placing it appropriately.

            scene.add(courtGroup);
        }
                
        function createPerson() {


            const personGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.5);
            const personMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            person = new THREE.Mesh(personGeometry, personMaterial);
            person.position.set(0, 0.75, -7);
            scene.add(person);

            walkToCourt();
        }

        function walkToCourt() {
            let progress = 0;
            function step() {
                if (progress < 5) {
                    person.position.z += 0.05;
                    progress += 0.05;
                    requestAnimationFrame(step);
                } else {
                    openDoors();
                }
            }
            step();


          
        }

        function openDoors() {
            if (doorOpened) return;
            doorOpened = true;
            


            let openProgress = 0;
            function animateDoors() {
                if (openProgress < 1) {
                    
                    doors[0].position.x -= 0.02;
                    doors[1].position.x += 0.02;
                    openProgress += 0.02;
                    requestAnimationFrame(animateDoors);
                }
            }
            animateDoors();

            
        }

        function animate() {
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
